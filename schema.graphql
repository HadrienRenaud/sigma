# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

" L'interface Group reprÃ©sente les deux types de groupes implÃ©mentÃ©s dans Sigma:- les groupes simples,dont les membres sont des utilisateurs,et - les mÃ©tagroupes,dont les membres sont des groupes simples(tel que Federez,dont les membres incluent le BR et DaTA)."
interface Group {
    admins: [User]
    announcementsFromGroup: [Announcement]
    announcementsToGroup: [Announcement]
    answers: [Answer]
    description: String
    eventsFromGroup: [Event]
    eventsToGroup: [Event]
    frontPage: String
    gid: ID!
    groupCoauthorEventRequestsToGroup: [GroupCoauthorEvent]
    groupJoinMetagroupRequestsToGroup: [GroupJoinMetagroup]
    mail: String
    name: String!
    privatePosts: [PrivatePost]
    questions: [Question]
    requestsToGroup: [Request]
    userJoinGroupRequestsToGroup: [UserJoinGroup]
    visibilityEdges: [Group]
    website: String
}

" L'interface Message reprÃ©sente toute information que veut communiquer un groupe ou un user.Par choix de paradigme,tout Message est adressÃ© Ã  un groupe(et un seul).Les types implÃ©mentÃ©s sont divisÃ©s en deux:- les Message Ã©manant d'un groupe:Announcement et Event,ainsi que Answer - les Message Ã©manant d'un user:PrivatePost,ainsi que Question "
interface Message {
    content: String!
    createdAt: DateTime!
    mid: ID!
    title: String!
    updatedAt: DateTime!
}

" DiffÃ©rents types de requÃªtes peuvent Ãªtre adressÃ©es Ã  un groupe.Elles sont stockÃ©es en BDD en attente d'Ãªtre traitÃ©es.Par exemple(le plus Ã©vident)demander Ã  devenir membre,mais il existe aussi d'autres cas de figure.On peut les voir comme des Mutations potentielles:en cas de validation de la requÃªte,des entrÃ©es de la BDD seront modifiÃ©es.Seuls les admins d'un Group(qu'il soit Simple ou Meta)ont le droit de valider ou refuser une requÃªte.Les diffÃ©rents types implÃ©mentant Request reprÃ©sentent des types de requÃªte:- UserJoinGroup:un User demande Ã  devenir membre d'un SimpleGroup - GroupCoauthorEvent:un groupe demande Ã  devenir(co-)organisateur d'un Ã©vÃ©nement *dÃ©jÃ  existant* "
interface Request {
    comment: String
    createdAt: DateTime!
    rid: ID!
    to: Group!
}

type Announcement implements Message {
    authors: [Group]
    content: String!
    createdAt: DateTime!
    forEvent: Event
    mid: ID!
    recipients: [Group]
    title: String!
    updatedAt: DateTime!
    views: Int
}

type Answer implements Message {
    author: Group
    content: String!
    createdAt: DateTime!
    forQuestion: Question!
    mid: ID!
    title: String!
    updatedAt: DateTime!
}

type Event implements Message {
    authors: [Group]
    content: String!
    createdAt: DateTime!
    endTime: DateTime!
    forAnnouncements: [Announcement]
    location: String!
    mid: ID!
    participatingGroups: [Group]
    participatingUsers: [User]
    recipients: [Group]
    startTime: DateTime!
    title: String!
    updatedAt: DateTime!
}

type GroupCoauthorEvent implements Request {
    comment: String
    createdAt: DateTime!
    forEvent: Event!
    from: Group!
    rid: ID!
    to: Group!
}

type GroupJoinMetagroup implements Request {
    comment: String
    createdAt: DateTime!
    from: SimpleGroup!
    rid: ID!
    to: MetaGroup!
}

type MetaGroup implements Group {
    admins: [User]
    announcementsFromGroup: [Announcement]
    announcementsToGroup: [Announcement]
    answers: [Answer]
    description: String
    eventsFromGroup: [Event]
    eventsToGroup: [Event]
    frontPage: String
    gid: ID!
    groupCoauthorEventRequestsToGroup: [GroupCoauthorEvent]
    groupJoinMetagroupRequestsToGroup: [GroupJoinMetagroup]
    mail: String
    members: [SimpleGroup]
    name: String!
    privatePosts: [PrivatePost]
    questions: [Question]
    requestsToGroup: [Request]
    userJoinGroupRequestsToGroup: [UserJoinGroup]
    visibilityEdges: [Group]
    website: String
}

type Mutation {
    acceptGroupCoauthorEventRequest(comment: String, request: ID!): Boolean
    acceptGroupJoinRequest(comment: String, request: ID!): Boolean
    acceptUserJoinRequest(comment: String, request: ID!): Boolean
    addVisibilityEdge(forGroup: ID!, visibleBy: ID!): Boolean
    censorAnnouncement(announcementToCensor: ID!): Boolean
    censorAnswer(answerToCensor: ID!): Boolean
    censorEvent(eventToCensor: ID!): Boolean
    censorPrivatePost(privatePostToCensor: ID!): Boolean
    censorQuestion(questionToCensor: ID!): Boolean
    createAnnouncement(content: String, forEvent: ID, fromGroup: ID!, title: String, toGroups: [ID!]): Announcement
    createAnswer(content: String, forQuestion: ID!, title: String): Answer
    createEvent(content: String, endTime: DateTime, forAnnouncement: ID, fromGroup: ID!, location: String, startTime: DateTime, title: String, toGroups: [ID!]): Event
    createPrivatePost(content: String, title: String, toGroup: ID!): PrivatePost
    createQuestion(content: String, title: String, toGroup: ID!): Question
    createSubgroup(fromGroup: ID!, subDescription: String, subGid: ID, subMail: String, subName: String!, subSchool: String, subWebsite: String): Group
    editAnnouncement(announcementToEdit: ID!, content: String, forEvent: ID, title: String): Announcement
    editAnswer(answerToEdit: ID!, content: String, title: String): Answer
    editEvent(content: String, endTime: DateTime, eventToEdit: ID!, forAnnouncement: ID, location: String, startTime: DateTime, title: String): Event
    editGroup(description: String, forGroup: ID!, frontPage: String, mail: String, name: String, school: String, website: String): Group
    editPassword(newPassword: String): Boolean
    editPrivatePost(content: String, privatePostToEdit: ID!, title: String): PrivatePost
    " Rappels du mÃ©mo rights:Par rapport Ã  un groupe donnÃ©,un user peut avoir diffÃ©rents niveaux de droits:- none:aucun droit,ne sait mÃªme pas que le groupe existe(typiquement,une connection oÃ¹ l'utilisateur ne s'est pas authentifiÃ©)- authenticated:sait que le groupe existe,aucun autre droit(une connection on-platal sans auth,ou une connection authentifiÃ©e)- viewer:le user a aussi accÃ¨s Ã  l'activitÃ© publique du groupe:frontpage,Q&A,liste des membres,speakers et admins -(inherited)member:le user a aussi acces Ã  l'activitÃ© interne du groupe:les PrivatePost,ainsi que les annonces et events dont le groupe est auteur ou destinataire - speaker:le user peut aussi parler au nom du groupe.Il a le droit de publier des annonces et d'organiser des Ã©vÃ¨nements -(inherited)admin:le user a tous les droits sur le groupe == Pour les groupes simples == - Member:- Un user est membre strict du groupe G s'il est member de G selon la BDD sous-jacente.- Un user est membre(hÃ©ritÃ©)du groupe G s'il est membre strict d'un de ses descendants.- Speaker:un user est speaker du groupe G s'il est speaker de G selon la BDD.Pas de notion d'hÃ©ritage de speaker.- Admin:- Un user est admin strict du groupe G s'il est admin de G selon la BDD.- Un user est admin(hÃ©ritÃ©)du groupe G s'il est admin strict d'un de ses ascendants.- Viewer:un user est viewer du groupe G - s'il est membre(hÃ©ritÃ©)de G,ou - s'il est membre(hÃ©ritÃ©)d'un groupe immÃ©diatement parent de G(one-edge-down visibility),ou - s'il est membre(hÃ©ritÃ©)d'un groupe faisant partie du champ \"visibilityEdge\" de G,ou - s'il est membre d'un mÃ©tagroupe dont G est membre(implicit visibility-edges).- Dans tous les autres cas,le user a le niveau de droits \"none\" ou \"authenticated\",selon le cas de figure.== Pour les mÃ©ta-groupes == - Un user est membre d'un mÃ©ta-groupe G s'il est membre(hÃ©ritÃ©)d'un groupe simple dans G.- Un user est speaker d'un mÃ©ta-groupe G s'il est speaker d'un groupe simple dans G.- Un user est admin d'un mÃ©ta-groupe G s'il est admin(hÃ©ritÃ©)d'un groupe simple dans G.- Un user est viewer d'un mÃ©ta-groupe G s'il est viewer d'un groupe simple dans G.Les mutations ci-dessous sont divisÃ©es en quatre,selon le niveau de droit requis pour pouvoir les appeler.Les Mutations concernant les *Requests* suivent Ã  peu prÃ¨s toutes le schÃ©ma suivant:- <typeAuteur>Request<NatureDeLaRequest>(auteur,destinataire,comment):Request - accept<NatureDeLaRequest>Request(request:ID!,comment:String):Boolean - refuse<NatureDeLaRequest>Request(request:ID!,comment:String):Boolean - le paramÃ¨tre est le rid de la Request Ã  accepter ou refuser - seul les admins du groupe destinataire peuvent accepter ou refuser une Request Les Mutations concernant les *Messages* suivent Ã  peu prÃ¨s toutes le schÃ©ma suivant:- create<TypeDeMessage>(auteur,destinataire,title,content,etc.):<TypeDeMessage> - edit<TypeDeMessage>(<typeDeMessage>ToEdit:ID!):<TypeDeMessage> - remove<TypeDeMessage>(<typeDeMessage>ToRemove:ID!):Boolean - = l'auteur supprime le message - pour les Messages oÃ¹ l'auteur est un utilisateur,seul l'auteur a le droit de remove son Message - pour les Messages oÃ¹ l'auteur est un groupe,n'importe quel admin du groupe(ou speaker selon le cas)a le droit de remove le Message - censor<TypeDeMessage>(<typeDeMessage>ToCensor:ID!):Boolean - = le groupe destinataire supprime le message - n'importe quel admin du groupe a le droit de censurer un Message qui lui est adressÃ© -(le destinataire est un Group pour tous les Messages)"
    editProfile(mail: String, nickname: String, phone: String): User
    editQuestion(content: String, questionToEdit: ID!, title: String): Question
    groupParticipate(forEvent: ID!, gid: ID!): Boolean
    groupRequestCoauthorEvent(comment: String, forEvent: ID!, fromGroup: ID!, toGroup: ID!): GroupCoauthorEvent
    groupRequestJoinMetagroup(comment: String, fromGroup: ID!, toMetagroup: ID!): GroupJoinMetagroup
    groupUnparticipate(forEvent: ID!, gid: ID!): Boolean
    likeGroup(gid: ID!): Boolean
    makeAdmin(forGroup: ID!, uid: ID!): User
    makeSpeaker(forGroup: ID!, uid: ID!): User
    refuseGroupCoauthorEventRequest(comment: String, request: ID!): Boolean
    refuseGroupJoinRequest(comment: String, request: ID!): Boolean
    refuseUserJoinRequest(comment: String, request: ID!): Boolean
    removeAnnouncement(announcementToRemove: ID!): Boolean
    removeAnswer(answerToRemove: ID!): Boolean
    removeEvent(eventToRemove: ID!): Boolean
    removePrivatePost(privatePostToRemove: ID!): Boolean
    removeQuestion(questionToRemove: ID!): Boolean
    removeUser(fromGroup: ID!, uid: ID!): User
    removeVisibilityEdge(forGroup: ID!, visibleBy: ID!): Boolean
    unlikeGroup(gid: ID!): Boolean
    unmakeAdmin(forGroup: ID!, uid: ID!): User
    unmakeSpeaker(forGroup: ID!, uid: ID!): User
    userLeaveGroup(gid: ID!): Boolean
    userParticipate(forEvent: ID!): Boolean
    userRequestJoinGroup(comment: String, toGroup: ID!): UserJoinGroup
    userUnparticipate(forEvent: ID!): Boolean
    writePostsSummary(content: String, forGroup: ID!): Boolean
}

type PrivatePost implements Message {
    author: User
    content: String!
    createdAt: DateTime!
    mid: ID!
    recipient: Group
    title: String!
    updatedAt: DateTime!
}

" @file DÃ©finit les types spÃ©ciaux Query et Mutation,points d'entrÃ©e du schÃ©ma GraphQL.@author akka vodol,kadabra,ofacklam "
type Query {
    allAnnouncements: [Announcement]
    allEvents: [Event]
    allGroups: [Group]
    allMessages: [Message]
    allPrivatePosts: [PrivatePost]
    allSimpleGroups: [SimpleGroup]
    announcement(mid: ID!): Announcement
    answer(mid: ID!): Answer
    dislikes: [Group]
    event(mid: ID!): Event
    group(gid: ID!): Group
    groupCoauthorEventRequest(rid: ID!): GroupCoauthorEvent
    groupJoinMetagroupRequest(rid: ID!): GroupJoinMetagroup
    metaGroup(gid: ID!): MetaGroup
    privatePost(mid: ID!): PrivatePost
    question(mid: ID!): Question
    searchTOL(address: String, givenName: String, groups: [String], lastName: String, mail: String, nationality: String, nickname: String, phone: String, school: String, studies: String): [User!]
    simpleGroup(gid: ID!): SimpleGroup
    user(uid: ID!): User
    userJoinGroupRequest(rid: ID!): UserJoinGroup
}

type Question implements Message {
    author: User
    content: String!
    createdAt: DateTime!
    forAnswers: [Answer]
    mid: ID!
    recipient: Group
    title: String!
    updatedAt: DateTime!
}

type SimpleGroup implements Group {
    admins: [User]
    announcementsFromGroup: [Announcement]
    announcementsToGroup: [Announcement]
    answers: [Answer]
    children: [SimpleGroup]
    description: String
    eventsFromGroup: [Event]
    eventsToGroup: [Event]
    frontPage: String
    gid: ID!
    groupCoauthorEventRequestsToGroup: [GroupCoauthorEvent]
    groupJoinMetagroupRequestsToGroup: [GroupJoinMetagroup]
    likers: [User]
    mail: String
    memberOfMeta: [MetaGroup]
    members: [User]
    name: String!
    parents: [SimpleGroup]
    privatePosts: [PrivatePost]
    questions: [Question]
    requestsToGroup: [Request]
    school: String
    speakers: [User]
    userJoinGroupRequestsToGroup: [UserJoinGroup]
    visibilityEdges: [Group]
    website: String
}

"Un utilisateur"
type User {
    address: String
    adminOf: [Group]
    birthdate: Date!
    givenName: String!
    inheritedAdminOf: [Group]
    inheritedMemberOf: [Group]
    lastName: String!
    likes: [Group]
    mail: String
    memberOf: [Group]
    nationality: String
    nickname: String
    phone: String
    photo: String
    questionsFromUser: [Question]
    school: String
    speakerOf: [Group]
    uid: ID!
}

type UserJoinGroup implements Request {
    comment: String
    createdAt: DateTime!
    from: User!
    rid: ID!
    to: SimpleGroup!
}


"A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar Date

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar Time
